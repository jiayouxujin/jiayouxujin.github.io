<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>用好英语系列1</title>
    <url>/2019-04-23-%E7%94%A8%E5%A5%BD%E8%8B%B1%E8%AF%AD%E7%B3%BB%E5%88%971/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个系列的文章是学习[英语麦克风]一个积累的文章，这里面会涉及到句型，例句等等。</p>
<p>希望自己能通过写这个系列的文章，让自己的思维，英语能够有所提高。</p>
<p>这个系列的文章更新规则是：</p>
<p><del>尽量做到每天更新</del></p>
<p><del>每周1 3 5为单词的更新 2 4 6 为句型的更新</del></p>
<p><del>一周一篇。希望对你有所帮助</del></p>
<h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><ul>
<li><input checked="" disabled="" type="checkbox"> 2019/4/23 <a href="#20190423">12岁女孩语惊四座，大人们羞愧难当</a></li>
</ul>
<p>###<span id="20190423">2019/4/23</span></p>
<blockquote>
<p><strong>Daily Must</strong></p>
<p>We can build a society where our actions align with our value</p>
<p>The most important thing is that everybody in car work together and turn the car around.</p>
</blockquote>
<p>align with 跟…一致</p>
<p>ex:Your actions should align with your words.</p>
<blockquote>
<p>​     is not like     or (growing) a few  in  .I am here to speak for all    to come.I am here to speak on behalf of the     around the world whose cries go unheard,for the countless    across this    because they have been    .</p>
<p><strong>ex1</strong></p>
<p>Losing our future is not like losing an election or a few points in stock market.I am here to speak for all generations to come.I am here to speak on behalf of the staving children around the world whose cries go unheard, for the countless animals dying across this planet because they have nowhere left to go.</p>
<p><strong>ex2</strong></p>
<p>Having a baby is not like keeping a pet or (growing) a few roses in the backyard.I am here to speak for all mothers to come.I am here to speak on behalf of the helpless mothers around the world whose cries go unheard,for the countless women struggling across this workplace because they have been treated unfairly.</p>
</blockquote>
<blockquote>
<p>Here you may be     of your     ,    or     ,but really your’re    and     ,    and     ,    and     ,and all of you are a    .</p>
<p><strong>ex1</strong></p>
<p>Here you may be delegates of your country,business people or politicians,but really you’re mothers and fathers,sisters and brothers,aunts and uncles,and all of you’re someone’s child. </p>
</blockquote>
<blockquote>
<p>And now    years have gone by,we have not even come close to achieving the     that we knew we needed back then.My    always say,”You are what you do,not what you say”.Well what you do makes me cry at night.You    say    .but I challenge you please make your actions reflect your words.Thank your.</p>
<p><strong>ex1</strong></p>
<p>And now twenty years have gone by,we have not even come close to achieving the sustainable transition that we knew we needed back then.My father always say,”You are what you do,not what you say.”Well,what you do makes cry at night.You grown-ups say you love us,but I challenge you,please make your actions reflect your words.Thank you.</p>
</blockquote>
<p>这部分内容全部都是演讲内容，演讲内容其实设计到一个Conclusion.</p>
<ol>
<li>So as you can see../To conclude…</li>
<li>First I told you about….,then I discussed …. and lastly,I explained…</li>
</ol>
<p>演讲的开头</p>
<ol>
<li>Coming up here today I have no hidden agenda.</li>
</ol>
<blockquote>
<p><strong>try</strong></p>
<p>Hello I am     speaking for 996.icu,the six days a week and every 12 hours a day organization.We’re a group of 24- and 40-year olds trying to make a difference.Coming up here today,I have no hidden agenda,I am fighting for my right.</p>
<p>I am here to speak for all employees to come.I am here to speak on behalf of the helpless workers around the world whose cries go unheard,for the countless people struggling across this workplace because they have been treated unfairly.</p>
<p>My teacher always says,”You are what you do ,not what you say”.Well,what you do makes me cry at night.You bosses say you love your employees,but I challenge you,please make your actions reflect your words.Thank you.</p>
</blockquote>
<h4 id="20190425"><a href="#20190425" class="headerlink" title="20190425"></a>20190425</h4><blockquote>
<p>pretty nerdy书呆子</p>
</blockquote>
<blockquote>
<p>How much did    pay    in    last year?They paid     more in     than    .This is    where     </p>
<p><strong>ex</strong></p>
<p>How much did a family pay for their child’s education in major cities last year?They paid 10 times more in education than those in rural areas.This is a competition where someone has already lost in very beginning.</p>
</blockquote>
<blockquote>
<p>There’s this massive appetite among    for solutions that will actually improve their    .I am the candidate to beat    because I’m focused on solving the     that    got    in the first place</p>
<p><strong>ex</strong></p>
<p>There’s this massive appetite among rural families for solutions that will actually improve their children’s education.I am the candidate to beat regional imbalance because I’m focused on solving the scarcity of educational resources that got those rural kids left behind in the first place. </p>
</blockquote>
<blockquote>
<p>Our     is not working for more and more Chinese and now I’m running for     to help change that and make     not the     in     anymore</p>
<p><strong>ex</strong></p>
<p>Our education system is not working for more and more Chinese and now I’m running for the  Minister Education to help change that and make our future generations not the losers in the global competition anytion</p>
</blockquote>
]]></content>
      <tags>
        <tag>用好英语</tag>
      </tags>
  </entry>
  <entry>
    <title>Java动态绑定和静态绑定详解</title>
    <url>/2019-04-20-java%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为什么突然写Java系列？因为突然发现自己以前学习都没有深入去理解一个知识点，搞的自己看起来都会，其实都不会。所以这个系列里，我会专门来讲Java中的知识点，并且会把这个知识点设计到的每个小知识点都提到。</p>
<hr>
<h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><blockquote>
<p>When compiler is not  able to resolve the call/binding at compile time,such binding is known as Dynamic or late Binding 。</p>
</blockquote>
<p>看到这里，我的表情是这样的:cry:</p>
<p>我们来看一下example</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 总共两个类 主类Boy继承Human</span></span><br><span class="line"><span class="comment"> * 类Human里有个方法walk() Boy对该方法进行重写(overriding)</span></span><br><span class="line"><span class="comment"> * 然后有三个对象obj obj1 obj2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Human walks"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boy</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Boy walks"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        Human obj=<span class="keyword">new</span> Boy();</span><br><span class="line">        Human obj2=<span class="keyword">new</span> Human();</span><br><span class="line">        Boy obj3=<span class="keyword">new</span> Boy();</span><br><span class="line"></span><br><span class="line">        obj.walk();</span><br><span class="line">        obj2.walk();</span><br><span class="line">        obj3.walk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tips:可以先自己想一下输出的结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">Boy walks</span><br><span class="line">Human walks</span><br><span class="line">Boy walks</span><br></pre></td></tr></table></figure>

<p>不知道跟你想的有没有一样？</p>
<p>好我们来分析一下这个代码:smile:在此之前我需要补充几个知识点【如果这两个知识点你还不熟悉的话，需要你往下看】</p>
<ul>
<li>java转型 向上转型或向下转型</li>
<li>重写和重载</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*obj是向下转型</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="java转型"><a href="#java转型" class="headerlink" title="java转型"></a>java转型</h3><h4 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h4><blockquote>
<p>upcasting is casting to a supertype and upcasting is always allowed</p>
</blockquote>
<blockquote>
<p>when we want to cast a Sub class to Super class to Super class</p>
</blockquote>
<p>这两句话的意思就是：当你想让子类转型成父类就是向上转型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有三个类 主类C的直接父类为B B的父类是A</span></span><br><span class="line"><span class="comment"> * 其中main函数定义了两个对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        A a=<span class="keyword">new</span> B();</span><br><span class="line">        a.a1();</span><br><span class="line">        B b=<span class="keyword">new</span> B();</span><br><span class="line">        b.a1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">B</span><br><span class="line">B</span><br></pre></td></tr></table></figure>

<p>可能看到这个结果有点疑惑[作为菜鸟的我又去查了资料]</p>
<blockquote>
<p>A cast from B to an A is an upcast,because B is-a A.In general,you can upcast whenever there is an is-a relationship between two classes.</p>
<p>[is-a]在知识表示、面向对象程序设计与面向对象设计的领域中表示类的父子继承关系</p>
</blockquote>
<p>现在应该比较好理解了，a呢实际上指向的是一个子类对象，只不过这个子类对象进行了upcasting。[不过由于向上转型，a对象可能会丢失和父类不同的方法—表示a对象只能调用父类继承过来的方法]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个代码是错误的不可运行</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        A a=<span class="keyword">new</span> B();</span><br><span class="line">        a.a1();</span><br><span class="line">        a.b1();<span class="comment">//这句话会报错</span></span><br><span class="line">        ((B) a).b1();</span><br><span class="line">        B b=<span class="keyword">new</span> B();</span><br><span class="line">        b.a1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能会觉得疑惑，这个向上转型有什么用？—增强了程序的简洁性:question:</p>
<p>这里又会设计到另外一个概念：<strong>类的多态</strong></p>
<h5 id="类的多态"><a href="#类的多态" class="headerlink" title="类的多态"></a>类的多态</h5><p>先来看一下example</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name,String address,<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Constructing an Employee"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.address=address;</span><br><span class="line">        <span class="keyword">this</span>.number=number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mailCheck</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"with employee"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Salary</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Salary</span><span class="params">(String name,String address,<span class="keyword">int</span> number,<span class="keyword">double</span> salary)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name,address,number);</span><br><span class="line">        setSalary(salary);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> salary)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(salary&gt;=<span class="number">0.0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.salary=salary;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mailCheck</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Within mailCkeck of Salary class"</span>);</span><br><span class="line">        System.out.println(<span class="string">"with salary"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VirtualDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        Salary s=<span class="keyword">new</span> Salary(<span class="string">"jin"</span>,<span class="string">"shanghai"</span>,<span class="number">1</span>,<span class="number">3.0</span>);</span><br><span class="line">        Employee e=<span class="keyword">new</span> Salary(<span class="string">"xu"</span>,<span class="string">"sh"</span>,<span class="number">2</span>,<span class="number">3.0</span>);</span><br><span class="line">        System.out.println(<span class="string">"Call mailCheck using Salary reference --"</span>);</span><br><span class="line">        s.mailCheck();</span><br><span class="line">        System.out.println(<span class="string">"Call mailCheck using Employee reference--"</span>);</span><br><span class="line">        e.mailCheck();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 预计运行结果</span></span><br><span class="line"><span class="comment"> * 都是通过mailCheck()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>先来猜测一下，输出结果是什么？</p>
<p>没错都是通过Salary类输出mailCheck();[在调试代码的时候，因为方法名字写错。对其有着更深理解 Salary类继承Empolyee 重写mailCheck()方法]</p>
<p>好了，那多态的概念是什么呢？</p>
<blockquote>
<p>多态指的是 Java的父类对象可以引用其所有子类对象。但是其引用完后，仍然是“父类对象”，只能调用父类中能够被子类继承的方法或者对象。</p>
</blockquote>
<p>从上面多态的例子和向上转型，你应该可以看出多态其实就是一种<strong>upcasting</strong>.</p>
<h4 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h4><blockquote>
<p>Downcasting is casting to a subtype and downcasting involves a type check and can throw a ClassCastException.</p>
</blockquote>
<p>定义就是讲，当父类对象转为子类，不过不像upcasting，会有ClassCastExeption的异常</p>
<p>你们查这个代码是否可以运行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VirtualDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        Employee e=<span class="keyword">new</span> Salary(<span class="string">"xu"</span>,<span class="string">"sh"</span>,<span class="number">2</span>,<span class="number">3.0</span>);</span><br><span class="line">        Employee ee=<span class="keyword">new</span> Employee(<span class="string">"xu"</span>,<span class="string">"sh"</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        Salary sss= (Salary) ee;</span><br><span class="line">        Salary ss= (Salary) e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实不行，会有ClassCastExveption异常。</p>
<p>为什么呢？因为在运行的时候 ee就是 Employee,当你让他变成Salary，就会抛出异常</p>
<p>所以为了不抛出异常就需要提前判断 (A instanceof B)</p>
<blockquote>
<p>instanceof is used to check if an object is an instance of a specific class</p>
</blockquote>
<h3 id="重写-overrding-与重载-overloading"><a href="#重写-overrding-与重载-overloading" class="headerlink" title="重写(overrding)与重载(overloading)"></a>重写(overrding)与重载(overloading)</h3><blockquote>
<p>overlading occurs when two or more methods in one class have the same method name but different parameters.</p>
<p>overriding means having two methods with the same method name and parameters.One of the methods is in the parent class and the other is in the child class.</p>
</blockquote>
<p>从定义我们可以看到，重写是发生在extends中，子类重写父类的方法。重载则是在同一类中的方法。</p>
<h3 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h3><blockquote>
<p>Static binding in java occurs during compile time</p>
<p>private,final and static methods and variables user static binding and are bonded by compiler.</p>
<p>static binding uses type (class in java)information for binding</p>
<p>overloading methods are bonded using static bindign</p>
</blockquote>
<p>通过研究动态绑定，我们可以很简单的学会静态绑定</p>
<ol>
<li>静态绑定发生在 static final private[就是无法被继承的类型]上</li>
<li>静态绑定是由class 类型决定的，因为是发生在编译时期</li>
<li><strong>overloading</strong> 也是静态绑定</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VirtualDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        Salary s=<span class="keyword">new</span> Salary(<span class="string">"jin"</span>,<span class="string">"shanghai"</span>,<span class="number">1</span>,<span class="number">3.0</span>);</span><br><span class="line">        Employee e=<span class="keyword">new</span> Salary(<span class="string">"xu"</span>,<span class="string">"sh"</span>,<span class="number">2</span>,<span class="number">3.0</span>);</span><br><span class="line">        Employee ee=<span class="keyword">new</span> Employee(<span class="string">"xu"</span>,<span class="string">"sh"</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        VirtualDemo virtualDemo=<span class="keyword">new</span> VirtualDemo();</span><br><span class="line">        virtualDemo.testOverloading(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testOverloading</span><span class="params">(Employee e)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Employee"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testOverloading</span><span class="params">(Salary ss)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Salary"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你能猜到输出结果吗？</p>
<p>结果是Empoyee</p>
<p>是不是很惊喜？？？</p>
<p>我们来分析一下这个代码：<br>首先 testOverloading是一个重载方法，所以是静态绑定，而静态绑定是由类类型决定，并且e是Employee类型，虽然其指向Salary对象，不过一点都不影响其静态绑定.</p>
<p>看到这里你应该对静态绑定有更深刻的了解了吧！[说实话，昨天我以为我懂了，今天发现好伐又有新东西。真好]</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>Here are a few important differences between static and dynamic binding:</p>
<ol>
<li>Static binding in Java occurs during compile time while dynamic binding occurs during runtime</li>
<li>private，final and static methods and variables use static binding and are bonded by compiler whiler virtual metods are bonded during runtime based upon runtime object</li>
<li>Static binding users Type (Class in Java) information for binding while dynamic binding uses object to resolve binding </li>
<li>Overloaded methods are bonded using static binding while overridden methods are boned using dynamic binding at runtime</li>
</ol>
</blockquote>
<p>如定义所说：动态绑定就是指在运行的时候，调用方法才跟方法体联系起来，而静态绑定是在编译的时候就联系起来。并且只有 final static private.这种没法被继承的，(在upcasting或者体现类多态的时候才会有“静态绑定”这一个说法)</p>
<p>以个例子收尾</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name,String address,<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Constructing an Employee"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.address=address;</span><br><span class="line">        <span class="keyword">this</span>.number=number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mailCheck</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"the static method of employee"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mailCheck2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"the public method of employee"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mailCheck3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"the private employee method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Salary</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> flag=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Salary</span><span class="params">(String name,String address,<span class="keyword">int</span> number,<span class="keyword">double</span> salary)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name,address,number);</span><br><span class="line">        setSalary(salary);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> salary)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(salary&gt;=<span class="number">0.0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.salary=salary;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mailCheck</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"with salary static method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mailCheck2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"public method of salary"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mailCheck3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"private method of salary"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VirtualDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        Salary s=<span class="keyword">new</span> Salary(<span class="string">"jin"</span>,<span class="string">"shanghai"</span>,<span class="number">1</span>,<span class="number">3.0</span>);</span><br><span class="line">        Employee e=<span class="keyword">new</span> Salary(<span class="string">"xu"</span>,<span class="string">"sh"</span>,<span class="number">2</span>,<span class="number">3.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化完后 需要进行验证</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 验证static 是静态绑定</span></span><br><span class="line"><span class="comment">         * 由分析得  s应该就是salary里的方法 e应该是employee里的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        s.mailCheck();</span><br><span class="line">        e.mailCheck();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 验证final是静态绑定</span></span><br><span class="line"><span class="comment">         * 由分析得  s应该是2</span></span><br><span class="line"><span class="comment">         *          e应该是1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(s.flag);</span><br><span class="line">        System.out.println(e.flag);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 最后验证public 是动态绑定 提升就是可以继承的是动态绑定</span></span><br><span class="line"><span class="comment">         * 由分析的 s是salary</span></span><br><span class="line"><span class="comment">         *          e也是salary</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        s.mailCheck2();</span><br><span class="line">        e.mailCheck2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 没有想到如何验证private</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">最后运行结果：</span><br><span class="line">这里留个悬念，希望读者自己去实现</span><br></pre></td></tr></table></figure>

<p>可以发现与分析结果完全相同。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>绑定</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/2019-04-20-%E6%A0%91/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为什么写这个系列，因为数据结构是计算机的基础课，而数据结构单单看是学不会的，所以需要练，并且这个系列中的每个专题都会不断更新。如有疑问欢迎提出</p>
<h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><ul>
<li><input checked="" disabled="" type="checkbox"> <p>2019-04-20首发日志</p>
</li>
<li><input checked="" disabled="" type="checkbox"> <p>2019-04-21更新<a href="#20190421">“有序数组构造二叉搜索树”</a></p>
</li>
<li><input disabled="" type="checkbox"> <p>2019-0-29更新<a href="#20190429">“二叉树的最大宽度”</a></p>
</li>
</ul>
<h3 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h3><p>简单说一些概念[容易跟《离散数学》混淆的定义]</p>
<ul>
<li>节点的度：节点拥有的子树数，在离散数学中即指的是 <strong>出度</strong></li>
<li>树的度：max(节点的度)</li>
</ul>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h4><ol>
<li>对任何一棵二叉树T，如果其叶子数为n0,度为2的节点数为n2,则<strong>n0=n2+1</strong></li>
<li>具有n个节点的完全二叉树的深度为[log2(2)]+1</li>
</ol>
<h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>#####前序遍历</p>
<p><strong>前序遍历</strong>指的是根节点、左节点、右节点</p>
<p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">leetcode114</a></p>
<p><strong>递归法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        preorderTraversal(root.left);</span><br><span class="line">        preorderTraversal(root.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>迭代法</strong></p>
<p>迭代法主要是利用到栈的结构，通过遍历我们可以看到 二叉树首先是 root 然后是root.left 当root.left==null的时候才是root.right; 这很符合栈的结构 <strong>先进后出</strong>。所以就是朝左节点遍历到最低，然后遍历右节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//先判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>||!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                list.add(root.val);</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root=root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root=stack.pop();</span><br><span class="line">                root=root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><p><strong>中序遍历</strong>左节点、根节点、右节点</p>
<p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">leetcode94</a></p>
<p><strong>递归法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        inorderTraversal(root.left);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        inorderTraversal(root.right);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>迭代法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>||!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root=root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root=stack.pop();</span><br><span class="line">                list.add(root.val);</span><br><span class="line">                root=root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><p><strong>后序遍历</strong>左节点、右节点、根节点</p>
<p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">leetcode145</a></p>
<p><strong>递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        postorderTraversal(root.left);</span><br><span class="line">        postorderTraversal(root.right);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>迭代法</strong></p>
<h5 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h5><p><strong>层序遍历</strong>顾名思义就是一层一层的遍历，从左往右的遍历.用到了队列的数据结构FIFO。先将根节点加入到队列中，然后遍历其左节点和右节点，如果不为空将其加入到队列中。</p>
<p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">leetcode102</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> count=queue.size();</span><br><span class="line">            <span class="keyword">while</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">leetcode107</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;List&lt;Integer&gt;&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt;queue =<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> count=queue.size();</span><br><span class="line">            <span class="keyword">while</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            res.add(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法二</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;List&lt;Integer&gt;&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt;queue =<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> count=queue.size();</span><br><span class="line">            <span class="keyword">while</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>,j=res.size()-<span class="number">1</span>;i&lt;j;i++,j--)&#123;</span><br><span class="line">            List&lt;Integer&gt; temp=res.get(i);</span><br><span class="line">            res.set(i,res.get(j));</span><br><span class="line">            res.set(j,temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树深度问题"><a href="#二叉树深度问题" class="headerlink" title="二叉树深度问题"></a>二叉树深度问题</h3><p>二叉树深度问题，其实就是用递归，刚才笔者又犯了个错误[递归如果如果去想清楚每一步怎么走是想不出来的]</p>
<ol>
<li>递归停止的 root==null</li>
<li>递归方程 depth=max(ld,rd)+1</li>
</ol>
<p>[递归的思想真的很巧妙，还是要多训练:smile:]</p>
<p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">leetcode104</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ld=maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> rd=maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(ld,rd)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">leetcode111</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> minDepth(root.left)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>&amp;&amp;root.left==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> minDepth(root.right)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> Math.min(minDepth(root.left),minDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="确定二叉树"><a href="#确定二叉树" class="headerlink" title="确定二叉树"></a>确定二叉树</h3><h4 id="中序遍历-前序遍历确定二叉树"><a href="#中序遍历-前序遍历确定二叉树" class="headerlink" title="中序遍历+前序遍历确定二叉树"></a>中序遍历+前序遍历确定二叉树</h4><p>解决步骤</p>
<ol>
<li>找到中序遍历跟前序遍历的第一个节点相等的地方</li>
<li>将中序遍历和前序遍历分为左右子树【这个地方特别小心】小心数组越界</li>
<li>递归</li>
</ol>
<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">leetcode105</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        TreeNode head=solu(preorder,inorder,<span class="number">0</span>,preorder.length-<span class="number">1</span>,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">solu</span><span class="params">(<span class="keyword">int</span>[] pre,<span class="keyword">int</span>[] in,<span class="keyword">int</span> prestart,<span class="keyword">int</span> preend,<span class="keyword">int</span> instart,<span class="keyword">int</span> inend)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prestart&gt;preend) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(prestart==preend) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(pre[prestart]);</span><br><span class="line">        <span class="comment">//开始构建 首先是前序遍历的第一个节点就是树或者（子树）的根节点</span></span><br><span class="line">        TreeNode head=<span class="keyword">new</span> TreeNode(pre[prestart]);</span><br><span class="line">        <span class="comment">//从中序遍历中找到这个根节点 将其分为左右子树</span></span><br><span class="line">        <span class="keyword">int</span> low=instart;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=low;i&lt;=inend;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i]==pre[prestart])&#123;</span><br><span class="line">                head.left=solu(pre,in,prestart+<span class="number">1</span>,prestart+i-instart,instart,i-<span class="number">1</span>);</span><br><span class="line">                head.right=solu(pre,in,prestart+i-instart+<span class="number">1</span>,preend,i+<span class="number">1</span>,inend);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">其中特别注意的是 prestart+i-instart.这个地方没有想到，因为你后面子树的结尾是要从你开头加起来，具体加多少，要看你移动了多少</span><br></pre></td></tr></table></figure>

<p>####中序遍历+后序遍历确定二叉树</p>
<p>解决方案</p>
<ol>
<li>从中序遍历中找到跟后序遍历的尾节点相同的点</li>
<li>将中序遍历和后序遍历分为左右两个子树</li>
<li>递归</li>
</ol>
<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">leetcode106</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        TreeNode head=solu(inorder,postorder,<span class="number">0</span>,inorder.length-<span class="number">1</span>,<span class="number">0</span>,postorder.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">solu</span><span class="params">(<span class="keyword">int</span>[] inorder,<span class="keyword">int</span>[] postorder,<span class="keyword">int</span> instart,<span class="keyword">int</span> inend,<span class="keyword">int</span> poststart,<span class="keyword">int</span> postend)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(poststart&gt;postend) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(poststart==postend) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(postorder[poststart]);</span><br><span class="line">        <span class="comment">//现在开始构建树 后续遍历的最后一个就是根节点</span></span><br><span class="line">        TreeNode head=<span class="keyword">new</span> TreeNode(postorder[postend]);</span><br><span class="line">        <span class="comment">//遍历中序遍历找到根节点 然后将其分为左右子树</span></span><br><span class="line">        <span class="keyword">int</span> low=instart;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=low;i&lt;=inend;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i]==postorder[postend])&#123;</span><br><span class="line">            head.left=solu(inorder,postorder,instart,i-<span class="number">1</span>,poststart,poststart+i-instart-<span class="number">1</span>);</span><br><span class="line">            head.right=solu(inorder,postorder,i+<span class="number">1</span>,inend,poststart+i-instart,postend-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="先序遍历构造二叉树"><a href="#先序遍历构造二叉树" class="headerlink" title="先序遍历构造二叉树"></a>先序遍历构造二叉树</h4><p>因为先序遍历无法确定，但是我们可以构造二叉树其中的一种特殊的树–二叉搜索树</p>
<p><a href="https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/" target="_blank" rel="noopener">leetcode1008</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">bstFromPreorder</span><span class="params">(<span class="keyword">int</span>[] preorder)</span> </span>&#123;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;preorder.length;i++)&#123;</span><br><span class="line">            setTreeNode(root,preorder[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTreeNode</span><span class="params">(TreeNode root,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.val&gt;i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>) setTreeNode(root.left,i);</span><br><span class="line">            <span class="keyword">else</span> root.left=<span class="keyword">new</span> TreeNode(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val&lt;i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>) setTreeNode(root.right,i);</span><br><span class="line">            <span class="keyword">else</span> root.right=<span class="keyword">new</span> TreeNode(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="完全二叉树的节点个数"><a href="#完全二叉树的节点个数" class="headerlink" title="完全二叉树的节点个数"></a>完全二叉树的节点个数</h4><p>首先我们可以知道完全二叉树的形式，都是先满足左节点，然后在满足右节点。所以可以通过不断遍历其左节点，就可以知道其深度。</p>
<ol>
<li>当左右子树的深度相同时，就说明左子树是一颗<strong>满二叉树</strong>其节点个数为(1&lt;&lt;ld) 其中ld为其深度+右子树的节点个数</li>
<li>当左右子树的深度不相同时，就说明右子树是一颗<strong>满二叉树</strong>其节点个数为(1&lt;&lt;rd)其中rd为其深度+左子树的节点个数</li>
</ol>
<p><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/submissions/" target="_blank" rel="noopener">LeetCode222</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过不断查找左节点可以得到其节点个数</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ld=getDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> rd=getDepth(root.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(ld==rd) <span class="keyword">return</span> (<span class="number">1</span>&lt;&lt;ld)+countNodes(root.right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (<span class="number">1</span>&lt;&lt;rd)+countNodes(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> depth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            depth++;</span><br><span class="line">            root=root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树其他问题"><a href="#二叉树其他问题" class="headerlink" title="二叉树其他问题"></a>二叉树其他问题</h3><h4 id="二叉树最近的公共祖先问题"><a href="#二叉树最近的公共祖先问题" class="headerlink" title="二叉树最近的公共祖先问题"></a>二叉树最近的公共祖先问题</h4><p>[占个坑 LCA问题]</p>
<h4 id="二叉树的最大宽度"><a href="#二叉树的最大宽度" class="headerlink" title="二叉树的最大宽度"></a><span id="20190429">二叉树的最大宽度</span></h4><p>思路：原先想用层序遍历，不过呢，这个最大宽度有涉及到Null节点。</p>
<p>​    所以需要对其用数组下标来遍历，对于任意的下标 i 节点，它的左节点下标为2*i 右节点下标为 2i+1</p>
<pre><code>用一个list来存储每一层的最左边的节点，然后通过 用右节点的下标位置-左节点下标位置，修改max</code></pre><p><a href="https://leetcode-cn.com/problems/maximum-width-of-binary-tree/" target="_blank" rel="noopener">leetcode662</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxW=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        dfs(root,<span class="number">1</span>,<span class="number">1</span>,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> maxW;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode r,<span class="keyword">int</span> level,<span class="keyword">int</span> index,List&lt;Integer&gt; left)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r==<span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(level&gt;left.size()) left.add(index);</span><br><span class="line">        maxW=Math.max(maxW,index-left.get(level-<span class="number">1</span>)+<span class="number">1</span>);</span><br><span class="line">        dfs(r.left,level+<span class="number">1</span>,index*<span class="number">2</span>,left);</span><br><span class="line">        dfs(r.right,level+<span class="number">1</span>,index*<span class="number">2</span>+<span class="number">1</span>,left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><blockquote>
<p>A Binary Search Tree (BST) is a tree in which all the nodes follow the bellow-mentions propries-</p>
<ul>
<li>the left sub-tree of a node  has a key less than or equal to its parent node’s key</li>
<li>the right sub-tree of a node has a key greater than  to its parent node’s key </li>
</ul>
</blockquote>
<h4 id="二叉搜索树的插入操作"><a href="#二叉搜索树的插入操作" class="headerlink" title="二叉搜索树的插入操作"></a>二叉搜索树的插入操作</h4><p>通过二叉搜索树的结构特征，可以观察到。其<strong>左节点值&lt;根节点值&lt;右节点值</strong>。所以其插入的判断较为简单[当然是在原二叉树中没有该值的时候]。不过，在实现的过程中确犯了两个错误，虽然通过调试都找到了</p>
<ol>
<li>return  root.我将root用来进行操作，这样就找不到原先的那棵树的根节点，而根节点一旦找不到，这棵树就“vanish”</li>
<li>while(true)  我只判断if，这样做是不行的，因为你得不断判断。将新值插入到二叉树中为止</li>
</ol>
<p><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/submissions/" target="_blank" rel="noopener">leetcode701</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        TreeNode cur=root;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(val&gt;cur.val)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">                cur.right=<span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">            cur=cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">                cur.left=<span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">            cur=cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉搜索树的删除操作"><a href="#二叉搜索树的删除操作" class="headerlink" title="二叉搜索树的删除操作"></a>二叉搜索树的删除操作</h4><p>通过二叉搜索树的结构特征，删除操作主要有这三种情况</p>
<ol>
<li>要删除的节点，其左子树为空，那么这个时候<strong>右子树</strong>就作为其根节点</li>
<li>要删除的节点，其右子树为空，那么这个时候<strong>左子树</strong>就作为其根节点</li>
<li>要删除的节点其左右子树都不为空，这个时候需要右子树中最小的值(即右子树中最左的节点)作为其根节点</li>
</ol>
<p>在进行编写代码的时候，笔者又不小心翻了车(找到最小的点的时候 应该先删除 然后在进 successor.left=root.left,不理解的可以拿起笔来画画)</p>
<p><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/submissions/" target="_blank" rel="noopener">leetcode450</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val&gt;key)&#123;</span><br><span class="line">            <span class="comment">//删除的节点在左子树</span></span><br><span class="line">            root.left=deleteNode(root.left,key);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&lt;key)&#123;</span><br><span class="line">            <span class="comment">//删除的节点在右子树</span></span><br><span class="line">            root.right=deleteNode(root.right,key);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//当前节点即为删除的节点</span></span><br><span class="line">            <span class="keyword">if</span>(root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode successor=min(root.right);</span><br><span class="line">                successor.right=delete(root.right);   <span class="comment">//笔者翻车的地方就在这里</span></span><br><span class="line">                successor.left=root.left;            <span class="comment">//可以把这两行代码对调一下</span></span><br><span class="line">                <span class="keyword">return</span> successor;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">min</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">delete</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        node.left=delete(node.left);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉搜索树的搜索操作"><a href="#二叉搜索树的搜索操作" class="headerlink" title="二叉搜索树的搜索操作"></a>二叉搜索树的搜索操作</h4><p>二叉搜索树的搜索操作，依据这其结构特征<strong>左节点&lt;根节点&lt;右节点</strong>+<strong>递归</strong>，可以很好的找到要搜索的值。</p>
<p><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener">leetcode700</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val&gt;val)&#123;</span><br><span class="line">            <span class="comment">//要查找的值在左子树</span></span><br><span class="line">            <span class="keyword">return</span> searchBST(root.left,val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&lt;val)&#123;</span><br><span class="line">            <span class="comment">//要查找的值在右子树</span></span><br><span class="line">            <span class="keyword">return</span> searchBST(root.right,val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是不满足于递归解决，我要用非递归的方法去解决,说实话一开始没有想到这么简单的方法，还是向上面那样，先来三个if然后在while。这个时候代码就非常庞大并且丑陋。[还是需要多看别人写的代码]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val&gt;val) root=root.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.val&lt;val) root=root.right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断是否是BST"><a href="#判断是否是BST" class="headerlink" title="判断是否是BST"></a>判断是否是BST</h4><p>由前中序遍历和BST的结构可以得出，如果是一棵BST其中序遍历为升序</p>
<p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">leetcode98</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> last=-Double.MAX_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(isValidBST(root.left))&#123;</span><br><span class="line">            <span class="keyword">if</span>(last&lt;root.val)&#123;</span><br><span class="line">                last=root.val;</span><br><span class="line">                <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="将有序数组转为二叉搜索树"><a href="#将有序数组转为二叉搜索树" class="headerlink" title="将有序数组转为二叉搜索树"></a><span id="20190421">将有序数组转为二叉搜索树</span></h4><p>有序数组其实对应着二叉树的中序遍历，所以这个应该属于二叉搜索树中序遍历的一种逆序</p>
<p>因为题目要求要构造一颗平衡二叉树，所以这就需要充数组中间，将其分为左右子树，然后反复递归</p>
<p><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">leetcod108</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums==<span class="keyword">null</span>?<span class="keyword">null</span>:buildTree(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> m=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(nums[m]);</span><br><span class="line">        root.left=buildTree(nums,l,m-<span class="number">1</span>);</span><br><span class="line">        root.right=buildTree(nums,m+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><h4 id="验证是否是平衡二叉树"><a href="#验证是否是平衡二叉树" class="headerlink" title="验证是否是平衡二叉树"></a>验证是否是平衡二叉树</h4><blockquote>
<p>平衡二叉树的严格定义是，任一个节点的左右子树的深度差不能超过1</p>
<p>所以我们就需要求 深度 ，由前面解题来看，我们可以用递归来求深度</p>
<p>并且因为是任意节点所以这里也考虑递归</p>
</blockquote>
<p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">leetcod110</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ld=deep(root.left);</span><br><span class="line">        <span class="keyword">int</span> rd=deep(root.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.abs(ld-rd)&lt;=<span class="number">1</span>&amp;&amp;isBalanced(root.left)&amp;&amp;isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deep</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ld=deep(root.left);</span><br><span class="line">        <span class="keyword">int</span> rd=deep(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(ld,rd)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>树</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
</search>
